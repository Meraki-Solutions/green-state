<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@symbiotic/green-state</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@symbiotic/green-state</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> @symbiotic/green-state</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="greenstate">GreenState</h1>
				<p>GreenState is a composable state management library for Javascript Apps with first-class support for IoC. It helps you write complex applications that can evolve in a sustainable way as requirements change by encapsulating state so it is easy to reason about what parts of the system would be impacted by a given change. It also encourages composition by providing a set of small re-usable units that can be combined in a variety of different ways.</p>
				<p>You can use GreenState with React using the provided bindings, or you could easily write a few small adapters to use it with any other view library.</p>
				<p>For a full reference of GreenState&#39;s API please visit <a href="https://symbioticlabs.github.io/green-state/">https://symbioticlabs.github.io/green-state/</a></p>
				<h2 id="table-of-contents">Table of Contents</h2>
				<ul>
					<li><a href="#installation">Installation</a></li>
					<li><a href="#api-reference">API Reference</a></li>
					<li><a href="#state-objects">State Objects</a></li>
					<li><a href="#basic-example">Basic Example</a></li>
					<li><a href="#react-example">React Example</a></li>
					<li><a href="#loading-state-asynchronously">Loading State Asynchronously</a></li>
					<li><a href="#state-classes-and-components">State Classes and Components</a><ul>
							<li><a href="#stringstate-and-injectstring">StringState and InjectString</a></li>
							<li><a href="#numberstate-and-injectnumber">NumberState and InjectNumber</a></li>
							<li><a href="#booleanstate-and-injectboolean">BooleanState and InjectBoolean</a></li>
							<li><a href="#injecttoggle-injecthover-and-injectfocus-react-components">InjectToggle, InjectHover and InjectFocus React components</a></li>
							<li><a href="#valuestate-and-injectvalue">ValueState and InjectValue</a></li>
							<li><a href="#arraystate-and-injectarray">ArrayState and InjectArray</a></li>
							<li><a href="#composite-state">Composite State</a></li>
						</ul>
					</li>
					<li><a href="#dependency-injection-and-inversion-of-control">Dependency Injection and Inversion of Control</a><ul>
							<li><a href="#getting-started-with-ioc-in-react">Getting Started with IOC in React</a></li>
							<li><a href="#inject-dependencies-into-components">Inject Dependencies into Components</a></li>
							<li><a href="#getting-multiple-dependencies">Getting Multiple Dependencies</a></li>
							<li><a href="#getting-dependencies-as-props">Getting Dependencies as Props</a></li>
							<li><a href="#sharing-state-using-ioc">Sharing State using IOC</a></li>
							<li><a href="#hierarchical-ioc-with-child-containers">Hierarchical IOC with Child Containers</a></li>
							<li><a href="#hierarchical-ioc-in-react">Hierarchical IOC in React</a></li>
						</ul>
					</li>
					<li><a href="#roadmap">Roadmap</a></li>
				</ul>
				<h2 id="installation">Installation</h2>
				<p>GreenState is available as a package on NPM for use with a module bundler.</p>
				<pre><code class="language-shell">npm install --save @symbiotic/green-state</code></pre>
				<h2 id="api-reference">API Reference</h2>
				<p>For a full reference of GreenState&#39;s API please visit <a href="https://symbioticlabs.github.io/green-state/">https://symbioticlabs.github.io/green-state/</a></p>
				<h2 id="state-objects">State Objects</h2>
				<p>When you use GreenState, the state of your app is stored in State objects, which can be subscribed to and also provide methods for changing the state. The only requirement for a State object to work with GreenState is that it implements this simple interface:</p>
				<pre><code class="language-js"><span class="hljs-keyword">const</span> myState = {
  <span class="hljs-comment">// Merge some keys into the state, just like React's this.setState when passed an object</span>
  setState(objectToMergeWithExistingState) {},

  <span class="hljs-comment">// Get the current state</span>
  <span class="hljs-keyword">get</span>() {},

  <span class="hljs-comment">// Subscribe to state changes, callback will be called every time state changes</span>
  subscribe(callback) {},
};</code></pre>
				<p>If you are comfortable using classes, you can extend the <code>State</code> class provided by GreenState, saving you from re-implementing the above interface every time. Any methods you add to your subclasses will be available to subscribers.</p>
				<h2 id="basic-example">Basic Example</h2>
				<p>As an illustration, here is a class that extends <code>State</code> to implement a simple counter with increment and decrement methods:</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { State } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{
  <span class="hljs-keyword">constructor</span>(initialCount = 0) {
    <span class="hljs-keyword">super</span>({ <span class="hljs-attr">count</span>: initialCount });
  }

  increment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span> })
  decrement = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">count</span>: <span class="hljs-keyword">this</span>.state.count - <span class="hljs-number">1</span> })
}

<span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> CounterState(<span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> unsubscribe = counter.subscribe(<span class="hljs-function">(<span class="hljs-params">{ count }</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(count)); <span class="hljs-comment">// Immediately logs 10</span>
counter.increment(); <span class="hljs-comment">// Logs 11</span>
counter.increment(); <span class="hljs-comment">// Logs 12</span>
counter.decrement(); <span class="hljs-comment">// Logs 11</span>

unsubscribe(); <span class="hljs-comment">// Stop listening to state changes</span></code></pre>
				<h2 id="react-example">React Example</h2>
				<p>GreenState provides react bindings that make it easy to subscribe to State and re-render your components using render props.</p>
				<pre><code class="language-js">import { Subscribe } from '@symbiotic/green-state';

const Counter = ({ initialCount }) =&gt; (
  /* The state methods (increment, decrement) are automatically passed to the render function along with the state */
  &lt;Subscribe to={() =&gt; new CounterState(initialCount)}&gt;
    {({ count, increment, decrement }) =&gt; (
      &lt;div&gt;
        &lt;button onClick={increment}&gt;Add&lt;/button&gt;
        Count: {count}
        &lt;button onClick={decrement}&gt;Subtract&lt;/button&gt;
      &lt;/div&gt;
    )}
  &lt;/Subscribe&gt;
);

const App = () =&gt; (
  &lt;div&gt;
    {/* 2 separate counters */}
    &lt;Counter initialCount={10} /&gt;
    &lt;Counter initialCount={20} /&gt;
  &lt;/div&gt;
);</code></pre>
				<p>Some important takeaways from this example:</p>
				<ul>
					<li>The <code>to</code> prop of the <code>&lt;Subscribe&gt;</code> component takes a function that must return a state object (with subscribe and get methods).</li>
					<li>Any methods of the state object are merged with the state values and passed to the render function, so adding actions to mutate state is simply a matter of adding methods to your state object.</li>
					<li>Since the state interface is very similar to React&#39;s setState, its quite easy to start with react state and then refactor to a State class if it gets more complex.</li>
					<li>Because our State class is separate from react, its easy to re-use it across components.</li>
					<li>Unsubscribing to state when the component unmounts is automatically handled by the <code>&lt;Subscribe&gt;</code> component.</li>
				</ul>
				<h2 id="loading-state-asynchronously">Loading State Asynchronously</h2>
				<p>Often state is not entirely local and must be loaded asynchronously before it can be used. For this reason, the <code>&lt;Subscribe&gt;</code> component&#39;s <code>to</code> prop supports returning a promise that resolves to a state object. Your render function will not be called until the state is loaded.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { State } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogPostsState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{
  loadPosts = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">loading</span>: <span class="hljs-literal">true</span> });

    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'...'</span>;
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url);
    <span class="hljs-keyword">const</span> { posts } = <span class="hljs-keyword">await</span> response.json();

    <span class="hljs-keyword">this</span>.setState({ posts, <span class="hljs-attr">loading</span>: <span class="hljs-literal">false</span> });
  };
};

<span class="hljs-keyword">const</span> loadBlogPosts = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> blogPostsState = <span class="hljs-keyword">new</span> BlogPostsState();
  <span class="hljs-keyword">await</span> blogPostsState.loadPosts();
  <span class="hljs-keyword">return</span> blogPostsState;
};

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Subscribe</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{loadBlogPosts}</span>&gt;</span>
      {({ posts, loading, loadPosts }) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          {loading &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading blog posts...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          }
          {!loading &amp;&amp;
            <span class="hljs-tag">&lt;&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                {posts.map(post =&gt; (
                  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{post.postId}</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                ))}
              <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadPosts}</span>&gt;</span>Refresh List<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/&gt;</span>
          }
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">Subscribe</span>&gt;</span></span>
  );
};</code></pre>
				<p>Key points from this example</p>
				<ul>
					<li>The <code>to</code> prop of the <code>&lt;Subscribe /&gt;</code> component can be a function that returns a promise so you can handle asynchronously loading state</li>
					<li>Subscribe will wait to call your render function until the state class calls setState (or initializes state in the constructor)</li>
				</ul>
				<h2 id="state-classes-and-components">State Classes and Components</h2>
				<p>We have found that many times we were re-writing the same state management pattern over and over. For example, toggling between 2 values (on/off, expanded/collapsed, mouseover/mouseout, etc.) or managing a string value (e.g. a form field). GreenState provides a number of state classes out of the box that we think speed up development by reducing the need to rewrite the same code over and over. GreenState also provides react components for each of these state classes to make it easy to use them with React.</p>
				<h3 id="stringstate-and-injectstring">StringState and InjectString</h3>
				<p><code>StringState</code> and <code>&lt;InjectString&gt;</code> are used for managing the value of a single string, for example in a form field.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { StringState, Subscribe, InjectString } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyForm = <span class="hljs-function">(<span class="hljs-params">{ initialValue = <span class="hljs-string">'Hello'</span> }</span>) =&gt;</span> (
  &lt;Subscribe to={() =&gt; new StringState(initialValue)}&gt;
    {({ value, set, clear, reset }) =&gt; (
      &lt;&gt;
        &lt;input
          type="text"
          value={value}
          onChange={e =&gt; set(e.target.value)}
        /&gt;
        &lt;button onClick={clear}&gt;Clear&lt;/button&gt; {/* Set to '' */}
        &lt;button onClick={reset}&gt;Reset&lt;/button&gt; {/* Set to initialValue */}
      &lt;/&gt;
    )}
  &lt;/Subscribe&gt;
);

// or use InjectString, same as above without needing both Subscribe and new'ing up the state class
const MyFormWithInject = ({ initialValue = 'Hello' }) =&gt; (
  &lt;InjectString initialValue={initialValue}&gt;
    {({ value, set, clear, reset }) =&gt; (
      &lt;&gt;
        &lt;input
          type="text"
          value={value}
          onChange={e =&gt; set(e.target.value)}
        /&gt;
        &lt;button onClick={clear}&gt;Clear&lt;/button&gt; {/* Set to '' */}
        &lt;button onClick={reset}&gt;Reset&lt;/button&gt; {/* Set to initialValue */}
      &lt;/&gt;
    )}
  &lt;/InjectString&gt;
);</code></pre>
				<h3 id="numberstate-and-injectnumber">NumberState and InjectNumber</h3>
				<p><code>NumberState</code> and <code>&lt;InjectNumber&gt;</code> are used for managing the value of a single number, for example the value of a range field.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { NumberState, Subscribe, InjectNumber } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyRangeField = <span class="hljs-function">(<span class="hljs-params">{ initialValue = <span class="hljs-number">0</span> }</span>) =&gt;</span> (
  &lt;Subscribe to={() =&gt; new NumberState(initialValue)}&gt;
    {({ value, set }) =&gt; (
      &lt;&gt;
        &lt;input
          type="range"
          value={value}
          onChange={e =&gt; set(Number(e.target.value))}
        /&gt;
      &lt;/&gt;
    )}
  &lt;/Subscribe&gt;
);

// or use InjectNumber, same as above without needing both Subscribe and new'ing up the state class
const MyRangeFieldWithInject = ({ initialValue = 0 }) =&gt; (
  &lt;InjectNumber initialValue={initialValue}&gt;
    {({ value, set }) =&gt; (
      &lt;&gt;
        &lt;input
          type="range"
          value={value}
          onChange={e =&gt; set(Number(e.target.value))}
        /&gt;
      &lt;/&gt;
    )}
  &lt;/InjectNumber&gt;
);</code></pre>
				<h3 id="booleanstate-and-injectboolean">BooleanState and InjectBoolean</h3>
				<p>Toggling between 2 states is a common requirement, and so GreenState provides a number of utilities to make this easier. <code>BooleanState</code> can be used to manage any boolean value, but GreenState also provides a number of convenient components to make common scenarios such as managing toggles, hover or focus more ergonomic.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { BooleanState, Subscribe, InjectBoolean } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyToggle = <span class="hljs-function">(<span class="hljs-params">initialValue = <span class="hljs-literal">false</span></span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Subscribe</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{()</span> =&gt;</span> new BooleanState(initialValue)}&gt;
    {({ value, set }) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set(!value)}&gt;
        {value ? 'TURN IT OFF' : 'TURN IT ON'}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">Subscribe</span>&gt;</span></span>
);

<span class="hljs-comment">// or use InjectBoolean, same as above without needing both Subscribe and new'ing up the state class</span>
<span class="hljs-keyword">const</span> MyToggleWithInject = <span class="hljs-function">(<span class="hljs-params">initialValue = <span class="hljs-literal">false</span></span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">InjectBoolean</span> <span class="hljs-attr">initialValue</span>=<span class="hljs-string">{initialValue}</span>&gt;</span>
    {({ value, set }) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set(!value)}&gt;
        {value ? 'TURN IT OFF' : 'TURN IT ON'}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">InjectBoolean</span>&gt;</span></span>
);</code></pre>
				<h3 id="injecttoggle-injecthover-and-injectfocus-react-components">InjectToggle, InjectHover and InjectFocus React components</h3>
				<p>The most common UI scenarios for managing a boolean value are some kind of toggle (expand/collapse), managing hover and managing focus. For this reason, GreenState provides a few additional React components based on BooleanState that provide more meaningful prop names than <code>value</code> and <code>set</code>.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { InjectHover, InjectFocus, InjectToggle } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyButton = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">InjectHover</span>&gt;</span>
    {({ isHovered, onMouseOver, onMouseOut }) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onMouseOver</span>=<span class="hljs-string">{onMouseOver}</span> <span class="hljs-attr">onMouseOut</span>=<span class="hljs-string">{onMouseOut}</span>&gt;</span>
        {isHovered ? 'IM HOVERED' : 'IM NOT HOVERED'}
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">InjectHover</span>&gt;</span></span>
);

<span class="hljs-keyword">const</span> MyField = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;InjectFocus&gt;
    {({ isFocused, onFocus, onBlur }) =&gt; (
      &lt;&gt;
        &lt;input onFocus={onFocus} onBlur={onBlur} /&gt;
        {isFocused &amp;&amp; &lt;span&gt;I am focused!&lt;/span&gt;}
      &lt;/&gt;
    )}
  &lt;/InjectFocus&gt;
);

const MySlider = () =&gt; (
  &lt;InjectToggle&gt;
    {({ isOn, isOff, on, off }) =&gt; (
      &lt;div&gt;
        &lt;label&gt;My Setting&lt;/label&gt;
        &lt;input type="radio" value="0" checked={isOff} onChange={off} /&gt; Off
        &lt;input type="radio" value="1" checked={isOn} onChange={on} /&gt; On
      &lt;/div&gt;
    )}
  &lt;/InjectToggle&gt;
);</code></pre>
				<h3 id="valuestate-and-injectvalue">ValueState and InjectValue</h3>
				<p>GreenState also provides a low level <code>ValueState</code> and <code>&lt;InjectValue</code>&gt; component which can be used to managing a single value of any type. Here is an example of managing the value of an object, but keep in mind that any type of value can be used with <code>ValueState</code>.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { ValueState, InjectValue, Subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyDogProfile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Subscribe</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{()</span> =&gt;</span> new ValueState({ name: 'Trevor', age: 7, eyeColor: 'blue', likes: 0 })}&gt;
    {({ value: dog, set }) =&gt; (
      <span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{dog.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Eyes:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.eyeColor}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Likes:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.likes}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set({ ...dog, likes: dog.likes + 1 })}&gt;Like this Dog<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">Subscribe</span>&gt;</span></span>
);

<span class="hljs-comment">// Or use InjectValue</span>
<span class="hljs-keyword">const</span> MyDogProfileWithInject = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">InjectValue</span> <span class="hljs-attr">initialValue</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">name:</span> '<span class="hljs-attr">Trevor</span>', <span class="hljs-attr">age:</span> <span class="hljs-attr">7</span>, <span class="hljs-attr">eyeColor:</span> '<span class="hljs-attr">blue</span>', <span class="hljs-attr">likes:</span> <span class="hljs-attr">0</span> }}&gt;</span>
    {({ value: dog, set }) =&gt; (
      <span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{dog.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Eyes:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.eyeColor}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Likes:<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {dog.likes}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set({ ...dog, likes: dog.likes + 1 })}&gt;Like this Dog<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">InjectValue</span>&gt;</span></span>
);</code></pre>
				<h3 id="arraystate-and-injectarray">ArrayState and InjectArray</h3>
				<p><code>ArrayState</code> and <code>&lt;InjectArray&gt;</code> are used for managing a list of values.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { ArrayState, Subscribe, InjectArray } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyGroceryList = <span class="hljs-function">(<span class="hljs-params">{ initialValues = [<span class="hljs-string">'Eggs'</span>, <span class="hljs-string">'Milk'</span>] }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Subscribe</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{()</span> =&gt;</span> new ArrayState(initialValues)}&gt;
    {({ values, set, push, removeElement, clear, reset }) =&gt; (
      <span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
          {values.map((value, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>
              {value}
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> removeElement(value)}&gt;X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> push('Toilet Paper')}&gt;Add Toilet Paper<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> push('Beer')}&gt;Add Beer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set(['Peanut Butter', 'Jelly'])}&gt;
          Use Saved List 1
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Overwrite with provided value */}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{clear}</span>&gt;</span>Clear<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Set to [] */}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{reset}</span>&gt;</span>Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Set to initialValues */}
      <span class="hljs-tag">&lt;/&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">Subscribe</span>&gt;</span></span>
);

<span class="hljs-comment">// or use InjectArray, same as above</span>
<span class="hljs-keyword">const</span> MyGroceryListWithInject = <span class="hljs-function">(<span class="hljs-params">{ initialValues = [<span class="hljs-string">'Eggs'</span>, <span class="hljs-string">'Milk'</span>] }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">InjectArray</span> <span class="hljs-attr">initialValues</span>=<span class="hljs-string">{initialValues}</span>&gt;</span>
    {({ values, set, push, removeElement, clear, reset }) =&gt; (
      <span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
          {values.map((value, index) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>
              {value}
              <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> removeElement(value)}&gt;X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          ))}
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> push('Toilet Paper')}&gt;Add Toilet Paper<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> push('Beer')}&gt;Add Beer<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> set(['Peanut Butter', 'Jelly'])}&gt;
          Use Saved List 1
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Overwrite with provided value */}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{clear}</span>&gt;</span>Clear<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Set to [] */}
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{reset}</span>&gt;</span>Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* Set to initialValues */}
      <span class="hljs-tag">&lt;/&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">InjectArray</span>&gt;</span></span>
);</code></pre>
				<h3 id="composite-state">Composite State</h3>
				<p>GreenState encourages you to create small re-usable state classes that encapsulate a single responsibility. A side effect of this is that you often may want to subscribe to multiple states. For example, imagine a list with a field above it that allows you to add items. We have the field value as well as the list values. This is easy enough to achieve by nesting Subscribe components but it can get difficult to read the more subscribes you have. GreenState provides a Compose component that allows you to compose react components such as InjectString together.</p>
				<p>This works with any component that uses render props (where you pass a function as the child). So GreenState&#39;s state components like InjectString can be composed with components that use render props such as formik, react power plug or react values.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Compose, InjectString, InjectArray } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> MyGroceryList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;Compose components={[
    InjectString,
    &lt;InjectArray initialValues={['Eggs']} /&gt; /* Create the component if you need to supply props */
  ]}&gt;
    {(
      newItem, // The first state, StringState
      groceryList // The second state, ArrayState
    ) =&gt; (
      &lt;&gt;
        &lt;form onSubmit={(e) =&gt; {
          e.preventDefault();
          groceryList.push(newItem.value);
          newItem.clear();
        }}&gt;
          &lt;label&gt;Add an Item&lt;/label&gt;
          &lt;input
            type="text"
            value={newItem.value}
            onChange={e =&gt; newItem.set(e.target.value)}
          /&gt;
        &lt;/form&gt;
        &lt;ul&gt;
          {groceryList.values.map((value, index) =&gt; (
            &lt;li key={index}&gt;
              {value}
              &lt;button onClick={() =&gt; groceryList.removeElement(value)}&gt;X&lt;/button&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/&gt;
    )}
  &lt;/Compose&gt;
);</code></pre>
				<p>An important caveat here is that composing states/components in this way means that the entire subscription will re-render every time ANY of the states change. This can cause performance issues if one of the subscriptions changes much more frequently than others or the render is expensive. This can be solved in a variety of ways (use separate subscriptions so you only re-render the relevant part of the tree, use pure components, etc. but this is a general react issue that is not unique to GreenState and is outside the scope of this documentation).</p>
				<h2 id="dependency-injection-and-inversion-of-control">Dependency Injection and Inversion of Control</h2>
				<p>As we decompose our application into small units that have a single responsibility, we end up needing to recombine these units to build up complex functionality. This is an incredibly powerful strategy for building complex applications that are easy to reason about and support refactoring as needed (as you can swap out an implementation when new behavior is desired without having to touch a lot of code). In order to easily swap out implementations, it&#39;s important that dependencies are injected into the classes that need them so that ClassA does not need to know how to create ClassB or any of its dependencies in order to use it. A trade off is that as your application grows, so does your dependency graph, such that getting an instance of ClassA may require resolving ClassB which needs ClassC, etc, etc. Manually managing dependencies is not a sustainable approach as it requires a lot of &quot;glue code&quot; and whenever your dependency graph changes you have to manually update the glue code to use the right dependencies. This is where DI containers come in handy. All of the knowledge of how to construct classes and their dependencies is pulled up into the container. In this way, control of how to instantiate classes is &quot;inverted&quot; from the within a class constructor to the container outside of the class. This is the heart of IoC. We gain a powerful tool for controlling how our classes and their dependencies are instantiated, and we can easily change that without touching the classes themselves. Here is a simple example.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">APIClientConfig</span> </span>{
  <span class="hljs-keyword">constructor</span>(baseURL) {
    <span class="hljs-keyword">this</span>.baseURL = baseURL;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">APIClient</span> </span>{
  <span class="hljs-comment">// The static inject array tells the container what services to instantiate and "inject" into the constructor</span>
  <span class="hljs-comment">// I need an instance of APIClientConfig as my first argument</span>
  <span class="hljs-keyword">static</span> inject = [APIClientConfig]

  <span class="hljs-keyword">constructor</span>(config) {
    <span class="hljs-keyword">this</span>.config = config;
  }

  getBlogPosts = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> { posts } = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.config.baseURL}</span>`</span>)
      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());

    <span class="hljs-keyword">return</span> posts;
  }

}

<span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> Container();

<span class="hljs-comment">// Let the container know to use this instance for config whenever its needed</span>
<span class="hljs-comment">// This might actually need to come from an API call itself or an environment variable at build time or it may need to be different depending on the logged in user</span>
<span class="hljs-comment">// But consumers of APIClientConfig don't need to know that</span>
container.registerInstance(APIClientConfig, <span class="hljs-keyword">new</span> APIClientConfig(<span class="hljs-string">'http://api.symbioticlabs.io/v1'</span>));

<span class="hljs-comment">// The container automatically injects APIClient with the right config</span>
<span class="hljs-comment">// You can imagine this is most useful when the line of code below is very far away from the registerInstance call above</span>
<span class="hljs-keyword">const</span> apiClient = container.get(APIClient);</code></pre>
				<h3 id="getting-started-with-ioc-in-react">Getting Started with IOC in React</h3>
				<p>In order to use GreenState&#39;s IOC features, you need to create a top-level <code>&lt;DependencyContainerContext&gt;</code> and wrap it around your app. Let&#39;s imagine you want to make a User object available anywhere in your application.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Inject, DependencyContainerContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">constructor</span>({ userId, username }) {
    <span class="hljs-keyword">this</span>.userId = userId;
    <span class="hljs-keyword">this</span>.username = username;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDependencyContainerContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DependencyContainerContext</span> </span>{
  <span class="hljs-comment">// Sub classes of DependencyContainerContext must implement containerMounted</span>
  <span class="hljs-keyword">async</span> containerMounted(container) {
    <span class="hljs-comment">// Imagine we loaded the user from the server, or local storage</span>
    <span class="hljs-keyword">const</span> currentUser = <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">userId</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">'trevor'</span> });

    <span class="hljs-comment">// You can use the container passed into containerMounted to add dependencies to the container</span>
    <span class="hljs-comment">// Note that you only need to manually register instances like this if the container cannot automatically resolve the dependency (by new'ing it up)</span>
    container.registerInstance(User, currentUser);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Inject</span> <span class="hljs-attr">diKey</span>=<span class="hljs-string">{User}</span>&gt;</span>
          {user =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello {user.username}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}
        <span class="hljs-tag">&lt;/<span class="hljs-name">Inject</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span></span>
    );
  }
}</code></pre>
				<p>Now that we have provided a top-level container context, any component anywhere in our application will be able to get at anything in the container, as we&#39;ll see in the next example.</p>
				<h3 id="inject-dependencies-into-components">Inject Dependencies into Components</h3>
				<p>In order to get an instance from the container in a component, you can use the <code>&lt;Inject&gt;</code> react component. For example, lets imagine we want to show the user profile in the header.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Inject</span> <span class="hljs-attr">diKey</span>=<span class="hljs-string">{User}</span>&gt;</span>
        {user =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.username}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Inject</span>&gt;</span></span>
    );
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"header"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span></span>
    );
  }
}</code></pre>
				<p>Using the <code>diKey</code> prop, we ask for the User key, and our render function receives the user instance from the container as its first argument.</p>
				<h3 id="getting-multiple-dependencies">Getting Multiple Dependencies</h3>
				<p>You can pass an array of keys to Inject with the <code>diKeys</code> props, and each key will be pulled from the container and passed as an argument to the render function.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Theme</span> </span>{
  primaryColor = <span class="hljs-string">'red'</span>
  secondaryColor = <span class="hljs-string">'black'</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Inject</span> <span class="hljs-attr">diKeys</span>=<span class="hljs-string">{[User,</span> <span class="hljs-attr">Theme</span>]}&gt;</span>
        {(user, theme) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.primaryColor</span> }}&gt;</span>{user.username}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Inject</span>&gt;</span></span>
    );
  }
}</code></pre>
				<h3 id="getting-dependencies-as-props">Getting Dependencies as Props</h3>
				<p>GreenState also provides a <code>withDependencies</code> Higher Order Component (HOC) which you can use to inject dependencies as props. This is especially useful if you need to use the dependencies in a class lifecycle method.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { withDependencies } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserProfile</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> { theme, user } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.primaryColor</span> }}&gt;</span>{user.username}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    );
  }
}

UserProfile = withDependencies({
  <span class="hljs-comment">// The key is the propName and the value is the dependency key</span>
  theme: Theme,
  <span class="hljs-attr">user</span>: User
})(UserProfile);</code></pre>
				<h3 id="sharing-state-using-ioc">Sharing State using IOC</h3>
				<p>It is common you may need to share access to a piece of state across components. For example, imagine you have a toast notification in your app and you want any component to be able to able to show a message.
				By putting the state into the container, it is easy to access it in any component with <code>&lt;Inject&gt;</code> or the <code>withDependencies</code> HOC.</p>
				<pre><code class="language-js">import { Inject, Subscribe, State, withDependencies } from '@symbiotic/green-state';

class GlobalNotificationState extends State {
  setMessage = ({ message, type = 'info' }) =&gt; this.setState({ message, type });
}

const AppNotificationBar = () =&gt; (
  &lt;Inject diKey={GlobalNotificationState}&gt;
    {notificationsState =&gt; (
      &lt;Subscribe to={() =&gt; notificationsState}&gt;
        {({ message, type }) =&gt; (
          &lt;div className={`alert-${type}`}&gt;{message}&lt;/div&gt;
        )}
      &lt;/Subscribe&gt;
    )}
  &lt;/Inject&gt;
);

let ShowMessageButton = ({ notifications }) =&gt; {
  &lt;button onClick={() =&gt; notifications.setMessage({ message: 'Hello!' })}&gt;
    Say Hello
  &lt;/button&gt;
};
ShowMessageButton = withDependencies({ notifications: GlobalNotificationState })(ShowMessageButton);

const App = () =&gt; (
    &lt;AppDependencyContainerContext&gt;
      &lt;AppNotificationBar /&gt;
      &lt;ShowMessageButton /&gt;
    &lt;/AppDependencyContainerContext&gt;
);</code></pre>
				<p>Note that these components are able to share state without having to know about each other. <code>AppNotificationBar</code> in the above example is a bit verbose as it needs to use <code>&lt;Inject&gt;</code> to get the state object and then <code>&lt;Subscribe&gt;</code> to subscribe to changes. GreenState provides an <code>&lt;InjectAndSubscribe&gt;</code> helper that makes this common paradigm more terse.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { InjectAndSubscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> AppNotificationBar = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">InjectAndSubscribe</span> <span class="hljs-attr">diKey</span>=<span class="hljs-string">{GlobalNotificationState}</span>&gt;</span>
    {({ message, type }) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">alert-</span>${<span class="hljs-attr">type</span>}`}&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )}
  <span class="hljs-tag">&lt;/<span class="hljs-name">InjectAndSubscribe</span>&gt;</span></span>
);</code></pre>
				<h3 id="hierarchical-ioc-with-child-containers">Hierarchical IOC with Child Containers</h3>
				<p>So far we have looked at creating a single DI container from which we can retrieve dependencies. GreenState supports creating child containers which inherit any of the dependencies from their parent container, but can also have their own services in them or override the parent services. Here is a basic example:</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { Container } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> Container();
container.registerInstance(User, <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">userId</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">'trevissimo'</span> }));

<span class="hljs-keyword">const</span> childContainer = container.createChild();
childContainer.registerInstance(Theme, { <span class="hljs-attr">primaryColor</span>: <span class="hljs-string">'green'</span>, <span class="hljs-attr">secondaryColor</span>: <span class="hljs-string">'black'</span> });

<span class="hljs-keyword">const</span> user = childContainer.get(User);
<span class="hljs-built_in">console</span>.log(user.username); <span class="hljs-comment">// 'trevissimo' from the parent container</span>

<span class="hljs-keyword">const</span> theme = childContainer.get(Theme);
<span class="hljs-built_in">console</span>.log(theme.primaryColor); <span class="hljs-comment">// 'green' from the child container</span></code></pre>
				<h4 id="use-cases-for-child-containers-">Use Cases for Child Containers:</h4>
				<ul>
					<li>Encapsulation: Often some services are only used by parts of your application and creating a child container to hold these related services keeps them scoped to that part of your application instead of being globally available in the root container.</li>
					<li>Garbage collection: If all of your services are in the root container then they are all global and will not be garbage collected even if the parts of your application are no longer being displayed.</li>
					<li>Overrides: Part of your application may want to override a specific service that is available in the root container with a different implementation. For example, perhaps part of your application wants to override/extend the theme service to include specific settings that are only relevant to it.</li>
				</ul>
				<h3 id="hierarchical-ioc-in-react">Hierarchical IOC in React</h3>
				<p>We used the <code>&lt;DependencyContainerContext&gt;</code> component earlier in order to make our user instance available to the container. You must have at least one component that extends <code>&lt;DependencyContainerContext&gt;</code>
				at the top of your application in order to use any of GreenState&#39;s ioc features such as <code>&lt;Inject&gt;</code>, <code>&lt;InjectAndSubscribe&gt;</code> and <code>withDependencies</code>. But you can also nest container contexts in your application in order to leverage Hierarchical IOC.</p>
				<pre><code class="language-js"><span class="hljs-keyword">import</span> { DependencyContainerContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'@symbiotic/green-state'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDependencyContainerContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DependencyContainerContext</span> </span>{
  <span class="hljs-keyword">async</span> containerMounted(container) {
    <span class="hljs-comment">// Parent container registers the user</span>
    container.registerInstance(User, <span class="hljs-keyword">new</span> User({ <span class="hljs-attr">userId</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">'trevissimo'</span> }));
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildDependencyContainerContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DependencyContainerContext</span> </span>{
  <span class="hljs-keyword">async</span> containerMounted(container) {
    <span class="hljs-comment">// A child container provides an overridden theme</span>
    container.registerInstance(Theme, { <span class="hljs-attr">primaryColor</span>: <span class="hljs-string">'green'</span>, <span class="hljs-attr">secondaryColor</span>: <span class="hljs-string">'black'</span> });
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span>
        {/* much deeper in the component hierarchy */}
        <span class="hljs-tag">&lt;<span class="hljs-name">ChildDependencyContainerContext</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Inject</span> <span class="hljs-attr">diKeys</span>=<span class="hljs-string">{[User,</span> <span class="hljs-attr">Theme</span>]}&gt;</span>
            {(user, theme) =&gt; (
              /* primaryColor is 'green' from the child container */
              /* user.username is 'trevissimo' from the parent container */
              <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.primaryColor</span> }}&gt;</span>{user.username}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            )}
          <span class="hljs-tag">&lt;/<span class="hljs-name">Inject</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ChildDependencyContainerContext</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AppDependencyContainerContext</span>&gt;</span></span>
    );
  }
}</code></pre>
				<h2 id="roadmap">Roadmap</h2>
				<ul>
					<li><input checked="" disabled="" type="checkbox"> TOC</li>
					<li><input checked="" disabled="" type="checkbox"> Public website + docs</li>
					<li><input checked="" disabled="" type="checkbox"> Don&#39;t pass setState: undefined, get: undefined to subscribers</li>
					<li><input disabled="" type="checkbox"> Better test coverage + badge</li>
					<li><input disabled="" type="checkbox"> Browser support information</li>
					<li><input disabled="" type="checkbox"> CI build pipeline</li>
					<li><input checked="" disabled="" type="checkbox"> TypeScript declarations</li>
					<li><input disabled="" type="checkbox"> Better TypeScript DX (reduced use of any, etc.)</li>
					<li><input disabled="" type="checkbox"> Additional bindings (angular, vue, etc.)</li>
					<li><input disabled="" type="checkbox"> Support for using a different DI/IoC framework or container implementation (inversify)</li>
					<li><input disabled="" type="checkbox"> Pre-compiled UMD package with window.GreenState global variable usable via script tag</li>
					<li><input disabled="" type="checkbox"> Decorator for injecting dependencies as props (currently only supports HOC)</li>
					<li><input disabled="" type="checkbox"> FAQ</li>
					<li><input disabled="" type="checkbox"> Contributing guide</li>
					<li><input disabled="" type="checkbox"> Node.js support for IOC portion</li>
					<li><input disabled="" type="checkbox"> Consider splitting into separate packages (state, react-state, ioc, react-ioc)</li>
					<li><input disabled="" type="checkbox"> Class annotations for singletons, transient, etc.</li>
					<li><input disabled="" type="checkbox"> Class annotations for child container only (without opting in, having a State class resolve in the root container when there are child containers can be a harmful default because it can lead to unintentionally sharing generic state classes across unrelated views)</li>
					<li><input disabled="" type="checkbox"> Document how to test state classes</li>
					<li><input checked="" disabled="" type="checkbox"> API Reference</li>
					<li><input disabled="" type="checkbox"> Troubleshooting / Gotchas<pre><code>- Accidental singletons in the root container shared across unrelated views (particularly problematic <span class="hljs-keyword">with</span> state)
- DI <span class="hljs-keyword">hierarchy</span> resolution, autoRegister, our custom <span class="hljs-keyword">container</span> resolution strategy
- <span class="hljs-keyword">Using</span> <span class="hljs-keyword">key</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">force</span> remount <span class="hljs-keyword">of</span> Subscribe <span class="hljs-keyword">or</span> prevent incorrect component re-<span class="hljs-keyword">use</span></code></pre></li>
					<li><input disabled="" type="checkbox"> DX Experience (debugging container, seeing all services)</li>
					<li><input disabled="" type="checkbox"> Feedback</li>
					<li><input disabled="" type="checkbox"> Recipes</li>
					<li><input disabled="" type="checkbox"> Basic Tutorial</li>
					<li><input disabled="" type="checkbox"> Advanced Tutorial</li>
					<li><input disabled="" type="checkbox"> Prior Art</li>
					<li><input disabled="" type="checkbox"> Logo</li>
					<li><input disabled="" type="checkbox"> Plugins? Make it extensible?</li>
					<li><input disabled="" type="checkbox"> Audit and improve bundle size</li>
					<li><input disabled="" type="checkbox"> UMD on CDN</li>
					<li><input disabled="" type="checkbox"> Multiple build targets (es6, commonjs, umd)</li>
					<li><input disabled="" type="checkbox"> License</li>
					<li><input disabled="" type="checkbox"> Core Concepts (State, IOC Container)</li>
					<li><input disabled="" type="checkbox"> Motivation / 3 Principles (Composition, Encapsulation, Inversion of Control)</li>
					<li><input disabled="" type="checkbox"> Naming conventions (Inject*, *Context)</li>
					<li><input disabled="" type="checkbox"> Design Decisions</li>
					<li><input disabled="" type="checkbox"> Better dispose (handle instance.dispose returning a rejected promise? Handle subsequent calls to container or state methods after dispose has been called?)</li>
					<li><input disabled="" type="checkbox"> Consider making async example actually work with a real API</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_react_dependencycontainercontext_.html">"ioc-<wbr>react/<wbr>Dependency<wbr>Container<wbr>Context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_react_dependencycontainerreactcontext_.html">"ioc-<wbr>react/<wbr>Dependency<wbr>Container<wbr>React<wbr>Context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_react_inject_.html">"ioc-<wbr>react/<wbr>Inject"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_react_injectandsubscribe_.html">"ioc-<wbr>react/<wbr>Inject<wbr>And<wbr>Subscribe"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_react_withdependencies_.html">"ioc-<wbr>react/with<wbr>Dependencies"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_ioc_container_.html">"ioc/<wbr>Container"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_compose_.html">"state-<wbr>react/<wbr>Compose"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectarray_.html">"state-<wbr>react/<wbr>Inject<wbr>Array"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectboolean_.html">"state-<wbr>react/<wbr>Inject<wbr>Boolean"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectfocus_.html">"state-<wbr>react/<wbr>Inject<wbr>Focus"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injecthover_.html">"state-<wbr>react/<wbr>Inject<wbr>Hover"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectnumber_.html">"state-<wbr>react/<wbr>Inject<wbr>Number"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectstring_.html">"state-<wbr>react/<wbr>Inject<wbr>String"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injecttoggle_.html">"state-<wbr>react/<wbr>Inject<wbr>Toggle"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_injectvalue_.html">"state-<wbr>react/<wbr>Inject<wbr>Value"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_react_subscribe_.html">"state-<wbr>react/<wbr>Subscribe"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_arraystate_.html">"state/<wbr>Array<wbr>State"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_booleanstate_.html">"state/<wbr>Boolean<wbr>State"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_numberstate_.html">"state/<wbr>Number<wbr>State"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_state_.html">"state/<wbr>State"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_stringstate_.html">"state/<wbr>String<wbr>State"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_state_valuestate_.html">"state/<wbr>Value<wbr>State"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>